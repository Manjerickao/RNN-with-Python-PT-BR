# -*- coding: utf-8 -*-
"""Untitled33.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1y6eCe81WBB34X2gIAC3Nlf5CUrejPU8b
"""

import tensorflow as tf
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import os
import urllib.request
import zipfile

# Exemplo da página: Previsão usando uma RNN profunda - página 557

# seeds para reprodutibilidade dos resultados
tf.random.set_seed(12)
np.random.seed(12)

# Link e caminhos para o dataset Jena Climate
data_url = "https://storage.googleapis.com/tensorflow/tf-keras-datasets/jena_climate_2009_2016.csv.zip"
zip_path = "jena_climate.zip"
csv_path = "jena_climate_2009_2016.csv"

# Verifica se o dataset já está baixado, se não, faz o download e extrai
if not os.path.exists(csv_path):
    print("Baixando dataset Jena Climate...")
    urllib.request.urlretrieve(data_url, zip_path)  # baixa o arquivo zip
    with zipfile.ZipFile(zip_path, "r") as zip_ref:
        zip_ref.extractall(".")  # extrai o conteúdo
    print("Download concluído.")

# Carrega os dados CSV para um DataFrame do pandas
df = pd.read_csv(csv_path)
print("Dados carregados. Exemplo:")
print(df.iloc[:, :5].head())  # exibe as 5 primeiras colunas para visualização inicial

# Seleciona apenas a coluna de temperatura (T (degC)), que é o alvo da previsão
temps = df["T (degC)"].values

# Normalização dos dados usando apenas os primeiros 60.000 valores para testes
split_index = 60000  # índice de corte entre treino e validação/teste
temps = temps[:split_index + 1000]  # mantém um pouco a mais para testar
mean_temp = temps[:split_index].mean()
std_temp = temps[:split_index].std()
temps_norm = (temps - mean_temp) / std_temp  # normaliza a série inteira

# Cria janelas deslizantes para previsão com TensorFlow Dataset
def create_tf_dataset(series, window_size, batch_size, shuffle_buffer):
    ds = tf.data.Dataset.from_tensor_slices(series)
    ds = ds.window(window_size + 1, shift=1, drop_remainder=True)  # cria janelas deslizantes
    ds = ds.flat_map(lambda w: w.batch(window_size + 1))  # transforma janela em batch
    ds = ds.shuffle(shuffle_buffer)
    ds = ds.map(lambda w: (w[:-1], w[-1]))  # entrada = todos os pontos menos o último, alvo = último ponto
    ds = ds.batch(batch_size).prefetch(1)  # agrupa em lotes e usa prefetch para otimização
    return ds

# Configurando a janela do treinamento
window_len = 72        # janela de 72 horas (3 dias)
batch_sz = 128         # tamanho do lote
shuffle_buf = 1000     # tamanho do buffer

# Cria o dataset com as janelas
dataset = create_tf_dataset(temps_norm, window_len, batch_sz, shuffle_buf)

# Construção do modelo de rede neural recorrente profunda com 3 camadas SimpleRNN como no livro
model = tf.keras.Sequential([
    tf.keras.layers.SimpleRNN(50, return_sequences=True, input_shape=(window_len, 1)),  # 1ª camada RNN
    tf.keras.layers.SimpleRNN(50, return_sequences=True),  # 2ª camada RNN
    tf.keras.layers.SimpleRNN(50),  # 3ª camada RNN ,última, não retorna sequência
    tf.keras.layers.Dense(1)  # camada de saída que prevê um único valor contínuo
])

# Compilação do modelo com função de perda MSE e otimizador Adam
model.compile(loss="mse", optimizer="adam")

# Treinamento do modelo por 10 épocas
history = model.fit(dataset, epochs=10)

# Visualização da perda durante o treino
plt.plot(history.history["loss"])
plt.title("Loss durante o treino")
plt.xlabel("Época")
plt.ylabel("MSE")
plt.grid(True)
plt.show()

# Realiza previsões em pontos arbitrários da série
for example_start in [100, 500, 1000]:
    # Seleciona a sequência de entrada (janela)
    input_seq = temps_norm[example_start:example_start + window_len].reshape(1, window_len, 1)
    # Faz a previsão (normalizada)
    prediction_norm = model.predict(input_seq)
    # Converte de volta para escala original da temperatura
    prediction = prediction_norm[0, 0] * std_temp + mean_temp
    # Obtém o valor real da temperatura (não normalizado)
    real_value = temps[example_start + window_len]
    # Calcula o erro absoluto
    erro_abs = abs(real_value - prediction)

    # Mostra a previsão, o valor real e o erro
    print(f"Previsão para {example_start + window_len}: {prediction:.2f}°C")
    print(f"Valor real: {real_value:.2f}°C")
    print(f"Erro absoluto: {erro_abs:.2f}°C\n")